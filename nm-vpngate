#!/usr/bin/env bash
#
# Yamada Hayao
# Twitter: @Hayao0819
# Email  : hayao@fascode.net
#
# (c) 2019-2021 Fascode Network.
#
# A script that makes it easy to connect Network Manager to a VPN Gate
# 
set -Eeu

# The directory where the script is located
script_path="$( cd -P "$( dirname "$(readlink -f "${0}")" )" && pwd )"

# CSV obtained from API will be assigned to this array line by line
CSV_SERVERLIST=()

# Whether to update the cache
# Do not define this value in the config file (it will constantly update the cache and make no sense)
# This variable changes to true only when the -u option is specified
UPDATE_CACHE=false

# List of paths of configuration files to be read
# Write in ascending order of priority
CONFIG_FILES=(
    "/etc/nm-vpngate.conf"
    "${HOME}/.nm-vpngate.conf"
    "${XDG_CONFIG_HOME-"${HOME}/.config"}/nm-vpngate.conf"
    "${script_path}/nm-vpngate.conf"
)

# Number of read configuration files
LOADED_CONFIG=()

# Number of attempts in auto mode
# The initial value is 1, and it increases by 1 for each failure.
# If it fails, it will try to connect to the next server.
AUTO_TRY_COUNT=1

# Backup of server list for AUTO MODE
AUTO_CSV_SERVERLIST=()

# About array in this code
# _parse_server_list parses the CSV and creates an array with each value assigned.
# CSV_SERVERLIST contains raw CSV line by line.
# This will be updated by _filter_server_list.
# The array name depends on the value set in CSV_VARS.
# For example, if CSV_VARS has an item called "IP", an array called IPList will be defined.
# The index numbers of all arrays are matched each other.
# For example, ${IPList[3]} and ${PingLisrt[3]} point to the same server.

#-- Message functions --#
_log(){   echo "[ LOG ]: ${1}" >&2; }
_msg(){
    [[ ! "${MODE}" = "GUI" ]] && echo "[${1}]: ${2}" >&2 && return 0
    zenity "--$(tr '[:upper:]' '[:lower:]' <<< "${1//" "/}")" --text "${2}" --title="${APP_NAME}" || true &
}
_info(){  _msg " INFO" "${1}"; }
_warn(){  echo "[ WARN]: ${1}" >&2; }
_error(){ 
    _msg "ERROR" "${1}"
    [[ -n "${2-""}" ]] || return 0 && exit "${2}"
}

#-- Check terminal or GUI --#
#test -t 0 || MODE="GUI" && MODE="CLI"

#-- Funcions -#

# 質問を行う関数
# Returns only the selected result to standard output
# ask_question -d <デフォルト値> -p <質問文> <選択肢1> <選択肢2> ...
ask_question(){
    local arg OPTARG OPTIND _default="" _choice_list _count _choice _question _mark
    while getopts "d:p:" arg; do
        case "${arg}" in
            d) _default="${OPTARG}" ;;
            p) _question="${OPTARG}" ;;
            *) exit 1 ;;
        esac
    done
    shift "$((OPTIND - 1))" ; _choice_list=("${@}") _digit="${##}"

    (( ${#_choice_list[@]} < 0 )) && _error "An exception error has occurred." && exit 1
    (( ${#_choice_list[@]} <= 1 )) && echo "${_choice_list[*]}" && return 0

    [[ -v _question ]] && [[ ! "${_question}" = "" ]] && echo -e "${_question}" >&2

    for (( _count=1; _count<=${#_choice_list[@]}; _count++)); do
        _choice="${_choice_list[$(( _count - 1 ))]}" _mark=" "
        { [[ ! "${_default}" = "" ]] && [[ "${_choice}" = "${_default}" ]]; } && _mark="*"
        printf " ${_mark} %${_digit}d: ${_choice}\n" "${_count}" >&2
    done
    echo -n "(1 ~ ${#_choice_list[@]}) > " >&2 && read -r _input
    { printf "%s" "${_input}" | grep -qE "^[0-9]+$";} && { (( 1 <= _input)) && (( _input <= ${#_choice_list[@]} )); } || return 1 && echo "${_choice_list[$(( _input - 1 ))]}" && return 0
    for (( i=0; i <= ${#_choice_list[@]} - 1 ;i++ )); do
        [[ "${_choice_list["${i}"],,}" = "${_input,,}" ]] && echo "${_choice_list["${i}"]}" && return 0
    done
}

_script_usage(){
    echo "usage ${0} [options]"
    echo
    echo "A script that makes it easy to connect Network Manager to a VPN Gate"
    echo
    echo " General options:"
    echo "    -a | --auto                Automatically connect to the server with the highest score"
    echo "    -c | --cli                 Set the mode to CLI"
    echo "    -g | --gtk                 Set thr mode to GTK (GUI)"
    echo "    -l | --limit [number]      Limit the number of automatic connection attempts"
    echo "    -r | --remove              Remove the settings when the connection fails"
    echo "    -t | --type [type]         Set the method of VPN (L2TP, OPENVPN)"
    echo "    -u | --update              Update the cache of server list"
    echo "    -h | --help                Show this help and exit"
    echo "         --nocache             Do not use cached server list"
    echo "         --country [country]   Set the country filter"
}

#-- Check environment and functions --#
_check_env(){
    local _exit=0

    # Check the number of loaded configuration files
    if (( "${#LOADED_CONFIG[@]}" < 1 )); then
        _error "No configuration file was found."
        _exit=$((_exit++))
    fi

    # Check external commands
    for _cmd in "nmcli" "curl" "systemctl"; do
        ! type "${_cmd}" 1> /dev/null 2>&1 && \
            _error "${_cmd} is not installed." && _exit=$((_exit++))
    done

    # Check NetworkManager VPN Plugin
    for _vpn in "openvpn" "strongswan" "l2tp" ;do
        ! [[ -f "/usr/lib/NetworkManager/VPN/nm-${_vpn}-service.name" ]] && \
            _error "NetworkManager Plugin for ${_vpn} is not installed." && _exit=$((_exit++))
    done

    # Check Metwork Manager
    ! systemctl is-active NetworkManager 1> /dev/null 2>&1 && \
        _error "NetworkManager is not running." && _exit=$((_exit++))

    # Exit if errors has been found
    (( _exit != 0 )) && exit 1 

    return 0
}

#-- Prepare environment --#
_prepare_env(){
    mkdir -p "${CONFIG_DIR}"
}

#-- Get server list from API or cache--#
_get_server_list(){
    _info "Getting and parsing the server list is in progress"
    if [[ "${UPDATE_CACHE}" = true ]] && [[ -f "${CACHE_PATH}" ]]; then
        _log "Remove and update cached server list"
        rm -rf "${CACHE_PATH}"
    fi
    
    if [[ -f "${CACHE_PATH}" ]] && [[ "${USE_CACHE}" = true ]]; then
        _log "Use cached server list in ${CACHE_PATH}"
        readarray -t CSV_SERVERLIST < <(grep -v "^\*" < "${CACHE_PATH}" | grep -v "^#")
    else
        _log "Getting server list from ${VPNGATE_CSV} ..."
        readarray -t CSV_SERVERLIST < <(curl -sL "${VPNGATE_CSV}" | grep -v "^\*" | grep -v "^#" | tee "${CACHE_PATH}")
    fi
}

#-- Filter server list --#
# This function takes a variable name as an argument.
# Filter the server list with the regular expression set
# in the passed variable and overwrite CSV_SERVERLIST.
# Be sure to run _parse_server_list after running this function.
#
# _filter_server_list <filter name>
# Example: _filter_server_list TargetIP
_filter_server_list(){
    # 変数を初期化
    local _Backup_CSV_SERVERLIST=("${CSV_SERVERLIST[@]}") _exp _clm _var="${1-""}" _empty=false
    CSV_SERVERLIST=()
    
    # $_var（$1）をもとにフィルター対象のカラムを設定
    # ここで設定した値をawkの変数名として使う
    _clm="$(tr "," "\n" <<< "${CSV_VARS}" | awk "{if (\$0 == \"${_var//Target/}\"){ print NR }}")"

    # フィルター処理
    if  [[ -z "${_var}" ]] || [[ -z "$(eval "echo \${${_var}}")" ]]; then 
        # フィルター設定がすべて空の場合はすべてのサーバを対象にする
        CSV_SERVERLIST=("${_Backup_CSV_SERVERLIST[@]}")
    else
        _exp="$(eval "echo \${${_var}}")"
        _log "Configured filters: ${_var}=${_exp}"
        readarray -t -O "${#CSV_SERVERLIST[@]}" CSV_SERVERLIST < <(awk "BEGIN {FS=\",\"} {
            if (\$${_clm} == \"${_exp}\" || \$${_clm} ~ /${_exp}/ ){
                print \$0
            }
        }" < <(printf "%s\n" "${_Backup_CSV_SERVERLIST[@]}"))
    fi

    # 重複しているサーバを削除
    readarray -t CSV_SERVERLIST < <(printf "%s\n" "${CSV_SERVERLIST[@]}" | awk '!a[$0]++{print}')

    # サーバリストが空の場合は終了する
    if (( "${#CSV_SERVERLIST[@]}" == 0 )) || [[ -z "${CSV_SERVERLIST[*]}" ]]; then
        _error "No server found. Please check Target* configs."
        exit 1
    fi
    _log "${#CSV_SERVERLIST[@]} servers found."
}

# Pass all variables starting with Target to _filter_server_list.
_run_filter(){
    local _var
    while read -r _var; do
        _filter_server_list "${_var}"
    done < <(tr " " "\n" <<< "${!Target*}")
}

#-- Parse server list --#
_parse_server_list(){
    local _cnt
    _log "Paring CSV ..."
    while read -r _cnt; do
        readarray -t "$(tr "," "\n" <<< "${CSV_VARS}" | head -n "${_cnt}" | tail -n 1)List" < <(printf "%s\n" "${CSV_SERVERLIST[@]}" | cut -d "," -f "${_cnt}")
    done < <(seq "1" "$(tr "," "\n" <<< "${CSV_VARS}" | wc -l)")
}

#-- Select server --#
_select_server_cli(){
    for _server in "${CSV_SERVERLIST[@]}"; do
        #readarray -t -O "${#_args[@]}" _args < <(tr "," "\n" <<< "${_server}" )
        _args+=("$(cut -d "," -f 1,2,7 <<< "${_server}")")
    done
    SelectedVPNName="$(ask_question -p "Please select server that you want to connect" "${_args[@]}" | cut -d "," -f 1)"
}
_select_server_gtk(){
    _log "Configuring graphical user interface ..."
    while read -r _var; do
        _args+=(--column="${_var}")
    done < <(tr "," "\n" <<< "${CSV_VARS}")
    for _server in "${CSV_SERVERLIST[@]}"; do
        readarray -t -O "${#_args[@]}" _args < <(tr "," "\n" <<< "${_server}" )
    done
    _args+=("--hide-column" "$(tr "," "\n" <<< "${CSV_VARS}" | wc -l)")
    if ! SelectedVPNName="$(zenity --list --title="${APP_NAME}" --text="Please select server that you want to connect" "${_args[@]}")"; then
        _log "zenity has terminated abnormally."
        exit 1
    fi
}
_select_server_auto(){
    AUTO_SETUP=true MODE="AUTO"
    _info "Auto mode has been selected. "
    local _sort_opt _value_list _target_value

    # Backup server list at first
    (( AUTO_TRY_COUNT < 2 )) && AUTO_CSV_SERVERLIST=("${CSV_SERVERLIST[@]}")

    # Change the argument of the sort command depending on the maximum or minimum value
    case "${AUTO_COND}" in
        "MAX")
            _log "Connect to the server with the highest ${AUTO_TARGET} value."
            _sort_opt=("-n" "-r")
            ;;
        "MIN")
            _log "Connect to the server with the lowest ${AUTO_TARGET} value."
            _sort_opt=("-n")
            ;;
        *)
            _error "Specify only MIN or MAX for AUTO_COND."
            exit 1
            ;;
    esac

    # Exit if the array of values specified by AUTO_TARGET does not exist
    if [[ -z "$(eval echo "\${${AUTO_TARGET}List[*]}")" ]]; then
        _error "The specified AUTO_TARGET is an invalid value."
        exit 1
    fi

    # Copy the array specified by AUTO_TARGET to _value_list
    readarray -t _value_list < <(eval "printf \"%s\n\" \"\${${AUTO_TARGET}List[@]}\"")

    # Get maximum or minimum
    _target_value="$(printf "%s\n" "${_value_list[@]}" | sort "${_sort_opt[@]}" | grep -E "^[0-9]+$" | head -n "${AUTO_TRY_COUNT}" | tail -n 1)"

    # Check whether  _target_value is number
    if ! printf "%s" "${_target_value}" | grep -qE "^[0-9]+$"; then
        _error "For AUTO_TARGET, enter only numerical items such as Ping."
        exit 1
    fi

    # Set conditions
    eval "Target${AUTO_TARGET}=^${_target_value}$"

    # Run filter
    _filter_server_list "Target${AUTO_TARGET}"
    _parse_server_list

    # Get the name from the filtered server list
    SelectedVPNName="$(cut -d "," -f 1 <<< "${CSV_SERVERLIST[0]}")"
}
_select_server(){
    if [[ "${AUTO_SETUP=false}" = true ]]; then
        _select_server_auto
    else
        case "${MODE}" in
            "GUI")
                _select_server_gtk
                ;;
            "CLI")
                _select_server_cli
                ;;
            "AUTO")
                _select_server_auto
                ;;
            *)
                _error "${MODE} is not correct"
                ;;
        esac
    fi
}

#-- Get server info from serner name --#
_get_server_from_name(){
    _log "Getting server information ..."
    if [[ -n "${SelectedVPNName-""}" ]]; then
        _log "Selected server name is ${SelectedVPNName}"
        SelectedIndex="$(awk "BEGIN {FS=\",\"} {
            if (\$1 == \"${SelectedVPNName}\" ){
                print NR - 1
            }
        }" < <(printf "%s\n" "${CSV_SERVERLIST[@]}") )"
    else
        _error "Failed to get server name"
        exit 1
    fi

    #_log "Index number is ${SelectedIndex}"
    _log "Server name:${HostNameList[${SelectedIndex}]}, IP: ${IPList[${SelectedIndex}]}, Country: ${CountryShortList[${SelectedIndex}]}"
}

#-- Parse format --#
_parse_profile_name(){
    PROFILE_NAME="${PROFILE_NAME_FORMAT}"
    _log "Parsing name format"
    while read -r _cnt; do
        PROFILE_NAME="${PROFILE_NAME//$(tr "," "\n" <<< "${CSV_VARS}" | head -n "${_cnt}" | tail -n 1)/$(eval "echo \${$(tr "," "\n" <<< "${CSV_VARS}" | head -n "${_cnt}" | tail -n 1)List[${SelectedIndex}]}")}"
    done < <(seq "1" "$(tr "," "\n" <<< "${CSV_VARS}" | wc -l)")
}

#-- Set up connection --#
_setup_vpn_openvpn(){
    local _ovpn_file="${CONFIG_DIR}/${PROFILE_NAME}.ovpn"

    #-- Save ovpn file --#
    _log "Save OVPN file to ${_ovpn_file}"
    [[ -f "${_ovpn_file}" ]] && _warn "Overwrite ${_ovpn_file}"
    echo -n "${OpenVPN_ConfigData_Base64List[${SelectedIndex}]}" | base64 -di > "${_ovpn_file}"

    #-- Import OVPN file --#
    _log "Import ${_ovpn_file}"
    nmcli connection import type openvpn file "${_ovpn_file}"
}

_setup_vpn_l2tp(){
    nmcli connection add \
        connection.id "${PROFILE_NAME}" con-name "${PROFILE_NAME}" type VPN vpn-type l2tp ifname -- \
        connection.autoconnect no ipv4.method auto vpn.data "gateway = ${IPList[${SelectedIndex}]}, ipsec-enabled = yes, mru = 1400, mtu = 1400, password-flags = 0, refuse-chap = yes, refuse-mschap = yes, refuse-pap = yes, require-mppe = yes, user = ${USERNAME}" vpn.secrets password="${PASSWORD}"
}

_setup_vpn(){
    if nmcli -c no con | sed "1d" | cut -d " " -f 1 | grep -qx "${PROFILE_NAME}"; then
        _warn "${PROFILE_NAME} has been added to the Network Manager"
        _warn "Skip to add it and continue to connent"
        return 0
    fi
    case "${VPN_TYPE}" in
        "OPENVPN")
            _setup_vpn_openvpn
            ;;
        "L2TP")
            _setup_vpn_l2tp
            ;;
    esac
}

#-- Connect to VPN --#
# PROFILE_NAMEのUUIDを返します
_get_uuid(){
    nmcli -c no con show | sed "1d" | awk "{ if (\$1 == \"${PROFILE_NAME}\"){ print \$2} }"
}

_connect_vpn(){
    local _exit=0

    # すでに接続されているか確認
    if nmcli -c no con show --active | sed "1d" | cut -d " " -f 1 | grep -qx "${PROFILE_NAME}"; then
        _warn "${PROFILE_NAME} has been avtivated on this system."
        _warn "Skip to connect it and exit."
        exit 0
    fi

    # 接続試行
    nmcli con up id "${PROFILE_NAME}" || _exit="${?}"

    # 接続に成功すれば終了
    (( _exit == 0)) && _info "Network Manager has been connected to VPN Gate (${PROFILE_NAME})" && exit 0

    # 失敗時の処理
    if [[ "${REMOVE_PROFILE}" = true ]]; then
        _error "Remove ${PROFILE_NAME} from Network Manager"
        nmcli con delete "${PROFILE_NAME}" || true
    fi
    if [[ "${MODE}" = "AUTO" ]] && { (( AUTO_LIMIT == 0 )) || (( AUTO_LIMIT > AUTO_TRY_COUNT )); }; then
        # 別のサーバで再接続を試みる
        AUTO_TRY_COUNT="$(( AUTO_TRY_COUNT + 1 ))"
        CSV_SERVERLIST=("${AUTO_CSV_SERVERLIST[@]}") # Reset server list
        _parse_server_list
        _select_server_auto
        _connect
    else
        _error "Network Manager has returned non-zero exit code."
        exit "${_exit}"
    fi
}

#-- Config --#
for _cfg in "${CONFIG_FILES[@]}"; do
    [[ ! -f "${_cfg}" ]] && continue
    source "${_cfg}" && LOADED_CONFIG+=("${_cfg}")
done

#-- Parse argument --#
OPTS=("a" "c" "g" "h" "t:" "u" "l:" "r") OPTL=("auto" "cli" "gtk" "type:" "help" "nocache" "country:" "update" "limit:" "remove")
GETOPT=(-o "$(printf "%s," "${OPTS[@]}")" -l "$(printf "%s," "${OPTL[@]}")" -- "${@}")
getopt -Q "${GETOPT[@]}" || exit 1 # 引数エラー判定
readarray -t OPT < <(getopt "${GETOPT[@]}") # 配列に代入
eval set -- "${OPT[@]}"
unset OPT OPTS OPTL DEFAULT_ARGUMENT GETOPT

while true; do
    case "${1}" in
        -a | --auto    ) MODE="AUTO"                 ; shift 1 ;;
        -c | --cli     ) MODE="CLI"                  ; shift 1 ;;
        -g | --gtk     ) MODE="GUI"                  ; shift 1 ;;
        -t | --type    ) VPN_TYPE="${2}"             ; shift 2 ;;
        -u | --update  ) UPDATE_CACHE=true           ; shift 1 ;;
             --country ) TargetCountryShort="^${2}$" ; shift 2 ;;
             --nocache ) USE_CACHE=false             ; shift 1 ;;
        -l | --limit   ) AUTO_LIMIT="${2}"           ; shift 2 ;;
        -r | --remove  ) REMOVE_PROFILE=true         ; shift 1 ;;
        -h | --help    ) _script_usage               ; exit  0 ;;
        --             ) shift 1                     ; break   ;;
        *)
            _error "Argument exception error '${1}'"
            _error "Please report this error to the developer with your command line argument."
            exit 1
            ;;
    esac
done

#-- Config message --#
for _cfg in "${LOADED_CONFIG[@]}"; do _log "Loaded ${_cfg}"; done

#-- Run --#
_prepare(){
    _check_env
    _prepare_env
    _get_server_list
    _run_filter
    _parse_server_list
}

_connect(){
    _get_server_from_name
    _parse_profile_name
    _setup_vpn
    _connect_vpn
}

_prepare
_select_server
_connect
exit 0
